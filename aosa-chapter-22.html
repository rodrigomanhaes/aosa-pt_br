c<html>
<head>
  <title>Arquitetura de Aplicações de Código Aberto: Violet</title>
</head>
<body>
  <h1>Capítulo 22. Violet</h1>
  <p id="author">Cay Horstmann</p>

  <p>Em 2002, eu escrevi um livro-texto para cursos de graduação de padrões e projeto orientado a objetos [Hor05]. Como acontece com muitos livros, este foi motivado pela frustração com o currículo padrão. Frequentemente, estudantes de ciência da computação aprendem como projetar uma classe única em seu primeiro curso de programação, e depois disto só voltam a ter treinamento em projeto orientado a objetos em seu curso de engenharia de software de nível superior. Neste curso, os estudantes passam rapidamente por curso de duas semanas de UML e padrões de projeto, que lhes dá não mais que uma ilusão de conhecimento. Meu livro dá suporte a um curso de um semestre para estudantes com um conhecimento prévio de programação Java e estruturas de dados básicas (tipicamente vindos de uma sequência CC1/CC2 baseada em Java). O livro cobre princípios de projeto orientado a objetos e padrões de projeto no contexto de situações familiares. Por exemplo, o padrão de projeto Decorator é introduzido com um <code>JScrollPane</code> do Swing, na esperança de que este exemplo seja mais memorável do que o exemplo padrão utilizando <i>streams</i> do Java.</p>

<p>Figura 22.1: Um diagrama de objetos do Violet</p>

<p>Eu precisava de um subconjunto leve da UML para o livro: diagramas de classes, diagramas de sequência e uma variação do diagrama de objetos que mostra referências para objetos Java (Figura 22.1). Eu também queria que os alunos pudessem desenhar seus próprios diagramas. Contudo, ofertas comerciais como Rational Rose eram não apenas caras, mas também difíceis de aprender e usar [Shu05] e as alternativas de código aberto disponíveis à época eram limitadas ou defeituosas demais para serem úteis, nas quais diagramas são especificados por declarações textuais em lugar das costumeiras interfaces baseadas no uso do mouse. Em particular, os diagramas de sequência do ArgoUML eram seriamente fracos.</p>

<p>Eu decidi tentar fazer algo a respeito implementando o editor mais simples possível que seja (a) útil para estudantes e (b) um exemplo de um <i>framework</i> extensível que os estudantes possam entender e modificar. Assim, Violet nasceu.</p>


<h2>22.1. Introduzindo Violet</h2>

<p>Violet é um editor UML leve, projetado para estudantes, professores e autores que precisem produzir diagramas UML simples rapidamente. É muito fácil de aprender e usar. Ele desenha diagramas de classes, sequência, estado, objetos e casos de uso. (Contribuições têm trazido outros tipos de diagramas.) É um software de código aberto e multiplataforma. Em seu núcleo, Violet usa um <i>framework</i> de grafos simples porém flexível, que tira o máximo proveito da API gráfica Java 2D.</p>

<p>A interface com o usuário de Violet é deliberadamente simples. Você não tem que navegar através de uma tediosa sequência de caixas de diálogo para inserir atributos e métodos. Ao contrário, você apenas os digita em um campo de texto. Com poucos cliques de mouse, você pode rapidamente criar diagramas simples e úteis.</p>

<p class='verificar'>Violet não tenta ser um software UML comercialmente competitivo. Aqui vão algumas funcionalidades que Violet <i>não</i> tem:</p>

<ul>
  <li>Violet não gera código-fonte a partir de diagramas UML nem diagramas UML a partir de código-fonte.</li>
  <li>Violet não realiza nenhuma verificação semântica de modelos; você pode desenhar diagramas contraditórios com Violet.</li>
  <li>Violet não gera arquivos que possam ser importados por outras ferramentas UML, nem é capaz de ler arquivos de modelos criados com outras ferramentas.</li>
  <li>Violet não tenta definir o <li>layout</li> dos diagramas automaticamente, exceto por uma funcionalidade de "ajustar à grade".</li>
</ul>

<p>(Tentar solucionar algumas destas limitações gera bons projetos de alunos.)</p>

<p class='verificar'>Quando Violet passou ser admirado por projetistas que queriam mais que um guardanapo mas menos que uma ferramenta UML de escala industrial, eu publiquei o código no SourceForge sob a Licença Pública da GNU (GNU Public License). Em 2005, Alexandre de Pellegrin entrou para o projeto ao criar um plugin para o Eclipse e uma interface com o usuário mais bonita. Desde então, ele realizou numerosas mudanças arquiteturais e agora é o principal mantenedor do projeto.</p>

<p>Neste artigo, eu discuto algumas das opções arquiteturais originais no Violet, bem como sua evolução. Uma parte do artigo é focada em edição de grafos, mas outras partes - como o uso de propriedades JavaBeans e persistência, Java WebStart e arquitetura de plugins - deve ser de interesse geral.</p>


<h2>O <i>Framework</i> de Grafos</h2>

<p>Violet é baseado em um <i>framework</i> de edição de grafos que pode renderizar e editar nós e arestas de formas arbitrárias. O editor de UML do Violet tem nós para classes, objetos, barras de ativação (em diagramas de sequência) e assim por diante, e arestas para os vários formatos de aresta em diagramas UML. Outra instância do <i>framework</i> de grafos pode exibir diagramas de entidade-relacionamento ou diagramas de sintaxe.</p>

<p>Figura 22.2: Uma Instância Simples do Editor</p>

<p>Para ilustrar o <i>framework</i>, vamos considerar um editor para grafos muito simples, com nós circulares pretos e brancos e arestas em linha reta (Figura 22.2). A classe <code>SimpleGraph</code> (grafo simples) especifica objetos protótipo para os tipos nó e aresta, ilustrando o padrão Prototype:</p>

<code>
public class SimpleGraph extends AbstractGraph
{
  public Node[] getNodePrototypes()
  {
    return new Node[]
    {
      new CircleNode(Color.BLACK),
      new CircleNode(Color.WHITE)
    };
  }
  public Edge[] getEdgePrototypes()
  {
    return new Edge[]
    {
      new LineEdge()
    };
  }
}
</code>

<p>Objetos protótipo são usados para desenhar os botões nó e aresta na parte superior da Figura 22.2. Eles são clonados sempre que o usuário adiciona uma nova instância de nó ou aresta ao grafo. <code>Node</code> (nó) e <code>Edge</code> (aresta) são interface com os seguintes métodos principais:</p>

<ul>
  <li>Ambas as interfaces têm um método <code>getShape</code> que retorna um objeto Java2D <code>Shape</code> da forma do nó ou aresta.</li>
  <li>A interface <code>Edge</code> tem métodos que fornecem os nós do início e do fim da aresta.</li>
  <li>O método <code>getConnectionPoint</code> (obter ponto de conexão) na interface <code>Node</code> calcula um ponto ideal de conexão na borda de um nó (ver Figura 22.3).</li>
  <li>O método <code>getConnectionPoints</code> da interface <code>Edge</code> fornece os dois pontos terminais da aresta. Este método é necessário para desenhar as "alças" que indicam a aresta selecionada no momento.</li>
  <li>Um nó pode ter filhos que se movem junto com o pai, e fornece métodos para enumerar e gerenciar filhos.</li>
</ul>

<p>Figura 22.3: Encontrando um Ponto de Conexão na Borda da Forma Nó</p>

<p>As classes de conveniência <code>AbstractNode</code> e <code>AbstractEdge</code> implementam uma quantidade destes métodos, e as classes <code>RectangularNode</code> e <code>SegmentedLineEdge</code> fornecem implementações completas de nós retangulares com uma string de título e bordas que são feitas de segmentos de linha.</p>

<p>No caso do nosso editor simples de grafos, nós precisaríamos prover um método <code>draw</code> (desenhar), um método <code>contains</code> (contém) e o método <code>getConnectionPoint</code>, que descreve a forma da borda do nó. O código é dado abaixo, e a Figura 22.4 mostra o diagrama de classes destas classes (desenhados, é claro, com Violet).</p>

<code>
public class CircleNode extends AbstractNode
{
  public CircleNode(Color aColor)
  {
    size = DEFAULT_SIZE;
    x = 0;
    y = 0;
    color = aColor;
  }

  public void draw(Graphics2D g2)
  {
    Ellipse2D circle = new Ellipse2D.Double(x, y, size, size);
    Color oldColor = g2.getColor();
    g2.setColor(color);
    g2.fill(circle);
    g2.setColor(oldColor);
    g2.draw(circle);
  }

  public boolean contains(Point2D p)
  {
    Ellipse2D circle = new Ellipse2D.Double(x, y, size, size);
    return circle.contains(p);
  }

  public Point2D getConnectionPoint(Point2D other)
  {
    double centerX = x + size / 2;
    double centerY = y + size / 2;
    double dx = other.getX() - centerX;
    double dy = other.getY() - centerY;
    double distance = Math.sqrt(dx * dx + dy * dy);
    if (distance == 0) return other;
    else return new Point2D.Double(
      centerX + dx * (size / 2) / distance,
      centerY + dy * (size / 2) / distance);
  }

  private double x, y, size, color;
  private static final int DEFAULT_SIZE = 20;
}

public class LineEdge extends AbstractEdge
{
  public void draw(Graphics2D g2)
  { g2.draw(getConnectionPoints()); }

  public boolean contains(Point2D aPoint)
  {
    final double MAX_DIST = 2;
    return getConnectionPoints().ptSegDist(aPoint) < MAX_DIST;
  }
}
</code>

<p>Figura 22.4: Diagrama de Classes para um Grafo Simples</p>

<p>Em resumo, Violet provê um <i>framework</i> simples para edição de grafos. Para obter uma instância do editor, definir classes nó e aresta e oferecer métodos em uma classe de grafos que gere objetos protótipo nó e aresta.</p>

<p>É claro, há outros <i>frameworks</i> de grafos disponíveis, como JGraph [Ald02] e JUNG(2). Contudo, estes <i>frameworks</i> são consideravelmente mais complexos e eles fornecem <i>frameworks</i> para desenho de grafos, não para aplicações que desenham grafos.</p>


<h2>O Uso de Propriedades JavaBeans</h2>

<p>Nos dias áureos do uso do Java no lado cliente, a especificação JavaBeans foi desenvolvida com o objetivo de proporcionar mecanismos portáveis de edição de componentes de interface gráfica em ambientes visuais de construção de interfaces gráficas. A visão era de que um componente criado por terceiros pudesse ser inserido em qualquer construtor de interfaces gráficas, onde suas propriedades poderiam ser configuradas do mesmo modo que componentes padrão como botões, caixas de texto e outros.</p>

<p>Java não possui suporte nativo a propriedades. Ao invés disto, propriedades JavaBeans podem ser acessadas por pares de métodos de acesso (<i>getters</i>) e alteração (<i>setters</i>) de atributos, ou especificados em classes <code>BeanInfo</code> associadas. Além disto, editores de propriedades podem ser especificados para editar visualmente valores de propriedades. O JDK contém até mesmo alguns editores básicos de propriedades, por exemplo, para a classe <code>java.awt.Color</code>.</p>

<p>O <i>framework</i> de Violet faz pleno uso da especificação JavaBeans. Por exemplo, a classe <code>CircleNode</code> pode expor uma propriedade cor simplesmente provendo dois métodos:</p>

<code>
public void setColor(Color newValue)
public Color getColor()
</code>

<p>Nenhum trabalho adicional é necessário. O editor de grafos pode agora alterar cores de nós circulares (Figura 22.5).</p>


<p>Figura 22.5: Editando Cores de Círculos com o Editor JavaBeans de Cores padrão</p>


<h2>Persistência de longo prazo</h2>

<p>Como qualquer editor, Violet deve salvar as criações do usuário em um arquivo e carregá-las posteriormente. Eu dei uma olhada na especificação XMI, que foi projetada como um formato de intercâmbio padrão para modelos UML. Eu o considerei pesado, confuso e difícil de consumir. Eu acredito não ter sido o único - XML tem uma reputação de interoperabilidade pobre mesmo para os modelos mais simples [PGL+05].</p>

<p>Eu pensei em simplesmente usar a serialização do Java, mas é difícil ler versões antigas de um objeto serializado cuja implementação foi alterada ao longo do tempo. Este problema também foi antecipado pelos arquitetos do JavaBeans, que desenvolveram um formato padrão de XML para persistência de longo prazo. Um objeto Java - no caso de Violet, um diagrama UML - é serializado como uma sequência de declarações para construí-lo e modificá-lo. Aqui está um exemplo:</p>

<code><pre>
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.0" class="java.beans.XMLDecoder">
 <object class="com.horstmann.violet.ClassDiagramGraph">
  <void method="addNode">
   <object id="ClassNode0" class="com.horstmann.violet.ClassNode">
    <void property="name">…</void>
   </object>
   <object class="java.awt.geom.Point2D$Double">
    <double>200.0</double>
    <double>60.0</double>
   </object>
  </void>
  <void method="addNode">
   <object id="ClassNode1" class="com.horstmann.violet.ClassNode">
    <void property="name">…</void>
   </object>
   <object class="java.awt.geom.Point2D$Double">
    <double>200.0</double>
    <double>210.0</double>
   </object>
  </void>
  <void method="connect">
   <object class="com.horstmann.violet.ClassRelationshipEdge">
    <void property="endArrowHead">
     <object class="com.horstmann.violet.ArrowHead" field="TRIANGLE"/>
    </void>
   </object>
   <object idref="ClassNode0"/>
   <object idref="ClassNode1"/>
  </void>
 </object>
</java>
</pre></code>

<p>Quando a classe <code>XMLDecoder</code> lê este arquivo, ela executa as declarações (nomes de pacotes são omitidos por motivo de simplicidade).</p>

<code>
ClassDiagramGraph obj1 = new ClassDiagramGraph();
ClassNode ClassNode0 = new ClassNode();
ClassNode0.setName(…);
obj1.addNode(ClassNode0, new Point2D.Double(200, 60));
ClassNode ClassNode1 = new ClassNode();
ClassNode1.setName(…);
obj1.addNode(ClassNode1, new Point2D.Double(200, 60));
ClassRelationShipEdge obj2 = new ClassRelationShipEdge();
obj2.setEndArrowHead(ArrowHead.TRIANGLE);
obj1.connect(obj2, ClassNode0, ClassNode1);
</code>

<p>Uma vez que a semântica dos construtores, propriedades e métodos não foram alteradas, uma nova versão do programa será capaz ler um arquivo que foi produzido por uma versão mais antiga.</p>

<p>Produzir tais arquivos é bastante simples. O codificador (<i>encoder</i>) automaticamente as propriedades de cada objeto e utiliza os métodos de alteração (<i>setters</i>) para cada propriedade cujo valor difere do valor padrão. Os tipos de dados mais básicos são manipulados pela plataforma Java; contudo, eu tive que fornecer manipuladores especiais para <code>Point2D</code>, <code>Line2D</code> e <code>Rectangle2D</code>. Mais importante, o codificador deve saber que um grafo pode ser serializado como uma sequência de chamadas aos métodos <code>addNode</code> e <code>connect</code>:</p>

<code>
encoder.setPersistenceDelegate(Graph.class, new DefaultPersistenceDelegate()
{
  protected void initialize(Class<?> type, Object oldInstance,
    Object newInstance, Encoder out)
  {
    super.initialize(type, oldInstance, newInstance, out);
    AbstractGraph g = (AbstractGraph) oldInstance;
    for (Node n : g.getNodes())
      out.writeStatement(new Statement(oldInstance, "addNode", new Object[]
      {
        n,
        n.getLocation()
      }));
    for (Edge e : g.getEdges())
      out.writeStatement(new Statement(oldInstance, "connect", new Object[]
      {
        e, e.getStart(), e.getEnd()
      }));
   }
 });
</code>

Uma vez que o codificador foi configurado, salvar um grafo é tão simples quanto:

<code>
encoder.writeObject(graph);
</code>

<p>Uma vez que o codificador simplesmente executa declarações, ele não requer configuração. Grafos são simplesmente lidos com:</p>

<code>
Graph graph = (Graph) decoder.readObject();
</code>

<p>Esta abordagem funcionou extremamente bem por numerosas versões de Violet, com uma exceção. Uma refatoração recente mudou alguns nomes de pacotes e assim quebrou a compatibilidade retroativa. Uma opção teria sido manter as classes em seus pacotes originais, mesmo que eles já não combinassem com a nova estrutura de pacotes. Em vez disto, o mantenedor forneceu um tradutor XML para reescrever os nomes dos pacotes ao ler um arquivo legado.</p>


<h2>Java WebStart</h2>

<p>Java WebStart é uma tecnologia para iniciar uma aplicação local a partir de um navegador <i>web</i>. É fornecido um arquivo JNLP que dispara uma aplicação de apoio no navegador que, por sua vez, baixa e roda o programa Java. A aplicação pode ser assinada digitalmente, situação na qual o usuário deve aceitar o certificado; ou pode ser não assinada, quando a aplicação roda em uma caixa de areia (<i>sandbox</i>) que é ligeiramente mais permissiva que a caixa de areia dos <i>applets</i>.</p>

<p class="verificar">Eu não penso que usuários finais possam ou devam ser capazes de julgar a validade de um certificado digital e suas implicações de segurança. Um dos pontos fortes da plataforma Java é sua segurança, e eu sinto que é importante "play to this strength"·</p>

<p>A caixa de areia do Java WebStart é suficientemente poderosa para permitir que usuários realizem trabalho útil, incluindo carregar e salvar arquivos e imprimir. Estas operações são tratadas de forma segura e conveniente do ponto de vista do usuário. O usuário é alertado de que a aplicação quer acessar o sistema de arquivos local e então escolhe o arquivo para ser lido ou escrito. A aplicação meramente recebe um objeto de fluxo (<i>stream</i>), sem ter a oportunidade de navegar pelo sistema de arquivos durante o processo de seleção do arquivo.</p>

<p>É incômodo que o desenvolvedor deva escrever código específico para interagir com um <code>FileOpenService</code> e um <code>FileSaveService</code> quando a aplicação está rodando sob o Java WebStart, e é ainda mais incômodo que não haja uma chamada na API do Java WebStart para informar se a aplicação foi iniciada com o Java WebStart.</p>

<p>Do mesmo modo, a armazenagem das preferências do usuário deve ser implementada de dois modos: usando a API de preferências quando a aplicação roda normalmente, ou usando o serviço de preferências do WebStart quando a aplicação está rodando sob o WebStart. Impressão, por outro lado, é inteiramente transparente ao programador da aplicação.</p>

<p>Violet provê camadas simples de abstração sobre estes serviços para simplificar sobremaneira o programador da aplicação. Por exemplo, aqui está o código para abrir um arquivo:</p>

<code>
FileService service = FileService.getInstance(initialDirectory);
  // detects whether we run under WebStart
FileService.Open open = fileService.open(defaultDirectory, defaultName,
  extensionFilter);
InputStream in = open.getInputStream();
String title = open.getName();
</code>

<p>A interface <code>FileService.Open</code> é implementada por duas classes: uma classe envelope (<i>wrapper</i>) sobre <code>JFileChooser</code> ou sobre <code>FileOpenService</code> da JNLP.</p>

<p>Nenhuma destas conveniências é parte da própria API do JNLP, mas esta API tem recebido pouco cuidado durante sua existência e tem sido largamente ignorada. A maioria dos projetos simplesmente usa um certificado autoassinado para sua aplicação WebStart, o que não provê segurança aos usuários. Isto é uma vergonha - desenvolvedores de software de código aberto deveriam reconhecer a caixa de areia do JNLP como um modo livre de riscos de experimentar um projeto.</p>


<h2>Java2D</h2>

<p>Violet faz uso intensivo da biblioteca Java2D, uma das joias menos conhecidas da API do Java. Todo nó e toda aresta têm um método <code>getShape</code> (obter forma) que devolve um <code>java.awt.Shape</code>, a interface comum a todas as formas Java2D. Esta interface é implementada por retângulos, círculos, caminhos e suas uniões, interseções e diferenças. A classe <code>GeneralPath</code> é útil para definir formas que são compostas por linhas arbitrárias e segmentos curvos quadráticos/cúbicos, como setas retas e curvas.</p>

<p>Para apreciar a flexibilidade do Java2D, considere o seguinte código para desenhar uma sombra no método <code>AbstractNode.draw</code>:</p>

<code>
Shape shape = getShape();
if (shape == null) return;
g2.translate(SHADOW_GAP, SHADOW_GAP);
g2.setColor(SHADOW_COLOR);
g2.fill(shape);
g2.translate(-SHADOW_GAP, -SHADOW_GAP);
g2.setColor(BACKGROUND_COLOR);
g2.fill(shape);
</code>

<p>Poucas linhas de código produzem uma sombra para cada forma, até mesmo formas que um desenvolvedor possa adicionar posteriormente.</p>

<p>Evidentemente, Violet salva images <i>bitmap</i> em qualquer formato que o pacote <code>javax.imageio</code> suporte; isto é, GIF, PNG, JPEG e assim por diante. Quando meu editor me perguntou sobre imagens vetoriais, eu notei outra vantagem da biblioteca Java2D. Quando você imprime em uma impressora PostScript, as operações do Java2D são traduzidas para operações de desenho vetorial do PostScript. Se você imprimir para um arquivo, o resultado poderá ser consumido por um programa como o <code>ps2eps</code> e então importado no Adobe Illustrator ou Inkscape. Aqui está o código, onde <code>comp</code> é o componente Swing cujo método <code>paintComponent</code> desenha o grafo:</p>

<code>
DocFlavor flavor = DocFlavor.SERVICE_FORMATTED.PRINTABLE;
String mimeType = "application/postscript";
StreamPrintServiceFactory[] factories;
StreamPrintServiceFactory.lookupStreamPrintServiceFactories(flavor, mimeType);
FileOutputStream out = new FileOutputStream(fileName);
PrintService service = factories[0].getPrintService(out);
SimpleDoc doc = new SimpleDoc(new Printable() {
  public int print(Graphics g, PageFormat pf, int page) {
      if (page >= 1) return Printable.NO_SUCH_PAGE;
      else {
        double sf1 = pf.getImageableWidth() / (comp.getWidth() + 1);
        double sf2 = pf.getImageableHeight() / (comp.getHeight() + 1);
        double s = Math.min(sf1, sf2);
        Graphics2D g2 = (Graphics2D) g;
        g2.translate((pf.getWidth() - pf.getImageableWidth()) / 2,
            (pf.getHeight() - pf.getImageableHeight()) / 2);
        g2.scale(s, s);

        comp.paint(g);
        return Printable.PAGE_EXISTS;
      }
  }
}, flavor, null);
DocPrintJob job = service.createPrintJob();
PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet();
job.print(doc, attributes);
</code>

<p class='verificar'>No início, eu estava preocupado com uma possível perda de desempenho ao usar formas gerais, mas provou-se não ser o caso. Clipping works well enough that only those shape operations that are required for updating the current viewport are actually executed .</p>



</body>
</html>

