<html>
<head>
  <title>Arquitetura de Aplicações de Código Aberto: Violet</title>
</head>
<body>
  <h1>Capítulo 22. Violet</h1>
  <p id="author">Cay Horstmann</p>

  <p>Em 2002, eu escrevi um livro-texto para cursos de graduação de padrões e projeto orientado a objetos [Hor05]. Como acontece com muitos livros, este foi motivado pela frustração com o currículo padrão. Frequentemente, estudantes de ciência da computação aprendem como projetar uma classe única em seu primeiro curso de programação, e depois disto só voltam a ter treinamento em projeto orientado a objetos em seu curso de engenharia de software de nível superior. Neste curso, os estudantes passam rapidamente por curso de duas semanas de UML e padrões de projeto, que lhes dá não mais que uma ilusão de conhecimento. Meu livro dá suporte a um curso de um semestre para estudantes com um conhecimento prévio de programação Java e estruturas de dados básicas (tipicamente vindos de uma sequência CC1/CC2 baseada em Java). O livro cobre princípios de projeto orientado a objetos e padrões de projeto no contexto de situações familiares. Por exemplo, o padrão de projeto Decorator é introduzido com um <code>JScrollPane</code> do Swing, na esperança de que este exemplo seja mais memorável do que o exemplo padrão utilizando <i>streams</i> do Java.</p>

<p>Figura 22.1: Um diagrama de objetos do Violet</p>

<p>Eu precisava de um subconjunto leve da UML para o livro: diagramas de classes, diagramas de sequência e uma variação do diagrama de objetos que mostra referências para objetos Java (Figura 22.1). Eu também queria que os alunos pudessem desenhar seus próprios diagramas. Contudo, ofertas comerciais como Rational Rose eram não apenas caras, mas também difíceis de aprender e usar [Shu05] e as alternativas de código aberto disponíveis à época eram limitadas ou defeituosas demais para serem úteis, nas quais diagramas são especificados por declarações textuais em lugar das costumeiras interfaces baseadas no uso do mouse. Em particular, os diagramas de sequência do ArgoUML eram seriamente fracos.</p>

<p>Eu decidi tentar fazer algo a respeito implementando o editor mais simples possível que seja (a) útil para estudantes e (b) um exemplo de um <i>framework</i> extensível que os estudantes possam entender e modificar. Assim, Violet nasceu.</p>


<h2>22.1. Introduzindo Violet</h2>

<p>Violet é um editor UML leve, projetado para estudantes, professores e autores que precisem produzir diagramas UML simples rapidamente. É muito fácil de aprender e usar. Ele desenha diagramas de classes, sequência, estado, objetos e casos de uso. (Contribuições têm trazido outros tipos de diagramas.) É um software de código aberto e multiplataforma. Em seu núcleo, Violet usa um <i>framework</i> de grafos simples porém flexível, que tira o máximo proveito da API gráfica Java 2D.</p>

<p>A interface com o usuário de Violet é deliberadamente simples. Você não tem que navegar através de uma tediosa sequência de caixas de diálogo para inserir atributos e métodos. Ao contrário, você apenas os digita em um campo de texto. Com poucos cliques de mouse, você pode rapidamente criar diagramas simples e úteis.</p>

<p class='verificar'>Violet não tenta ser um software UML comercialmente competitivo. Aqui vão algumas funcionalidades que Violet <i>não</i> tem:</p>

<ul>
  <li>Violet não gera código-fonte a partir de diagramas UML nem diagramas UML a partir de código-fonte.</li>
  <li>Violet não realiza nenhuma verificação semântica de modelos; você pode desenhar diagramas contraditórios com Violet.</li>
  <li>Violet não gera arquivos que possam ser importados por outras ferramentas UML, nem é capaz de ler arquivos de modelos criados com outras ferramentas.</li>
  <li>Violet não tenta definir o <li>layout</li> dos diagramas automaticamente, exceto por uma funcionalidade de "ajustar à grade".</li>
</ul>

<p>(Tentar solucionar algumas destas limitações gera bons projetos de alunos.)</p>

<p class='verificar'>Quando Violet passou ser admirado por projetistas que queriam mais que um guardanapo mas menos que uma ferramenta UML de escala industrial, eu publiquei o código no SourceForge sob a Licença Pública da GNU (GNU Public License). Em 2005, Alexandre de Pellegrin entrou para o projeto ao criar um plugin para o Eclipse e uma interface com o usuário mais bonita. Desde então, ele realizou numerosas mudanças arquiteturais e agora é o principal mantenedor do projeto.</p>

<p>Neste artigo, eu discuto algumas das opções arquiteturais originais no Violet, bem como sua evolução. Uma parte do artigo é focada em edição de grafos, mas outras partes - como o uso de propriedades JavaBeans e persistência, Java WebStart e arquitetura de plugins - deve ser de interesse geral.</p>


<h2>O Framework de Grafos</h2>

<p>Violet é baseado em um framework de edição de grafos que pode renderizar e editar nós e arestas de formas arbitrárias. O editor de UML do Violet tem nós para classes, objetos, barras de ativação (em diagramas de sequência) e assim por diante, e arestas para os vários formatos de aresta em diagramas UML. Outra instância do framework de grafos pode exibir diagramas de entidade-relacionamento ou diagramas de sintaxe.</p>

<p>Figura 22.2: Uma Instância Simples do Editor</p>

<p>Para ilustrar o framework, vamos considerar um editor para grafos muito simples, com nós circulares pretos e brancos e arestas em linha reta (Figura 22.2). A classe <code>SimpleGraph</code> (grafo simples) especifica objetos protótipo para os tipos nó e aresta, ilustrando o padrão Prototype:</p>

<code>
public class SimpleGraph extends AbstractGraph
{
  public Node[] getNodePrototypes()
  {
    return new Node[]
    {
      new CircleNode(Color.BLACK),
      new CircleNode(Color.WHITE)
    };
  }
  public Edge[] getEdgePrototypes()
  {
    return new Edge[]
    {
      new LineEdge()
    };
  }
}
</code>

<p>Objetos protótipo são usados para desenhar os botões nó e aresta na parte superior da Figura 22.2. Eles são clonados sempre que o usuário adiciona uma nova instância de nó ou aresta ao grafo. <code>Node</code> (nó) e <code>Edge</code> (aresta) são interface com os seguintes métodos principais:</p>

<ul>
  <li>Ambas as interfaces têm um método <code>getShape</code> que retorna um objeto Java2D <code>Shape</code> da forma do nó ou aresta.</li>
  <li>A interface <code>Edge</code> tem métodos que fornecem os nós do início e do fim da aresta.</li>
  <li>O método <code>getConnectionPoint</code> (obter ponto de conexão) na interface <code>Node</code> calcula um ponto ideal de conexão na borda de um nó (ver Figura 22.3).</li>
  <li>O método <code>getConnectionPoints</code> da interface <code>Edge</code> fornece os dois pontos terminais da aresta. Este método é necessário para desenhar as "alças" que indicam a aresta selecionada no momento.</li>
  <li>Um nó pode ter filhos que se movem junto com o pai, e fornece métodos para enumerar e gerenciar filhos.</li>
</ul>

<p>Figura 22.3: Encontrando um Ponto de Conexão na Borda da Forma Nó</p>

<p>As classes de conveniência <code>AbstractNode</code> e <code>AbstractEdge</code> implementam uma quantidade destes métodos, e as classes <code>RectangularNode</code> e <code>SegmentedLineEdge</code> fornecem implementações completas de nós retangulares com uma string de título e bordas que são feitas de segmentos de linha.</p>

<p>No caso do nosso editor simples de grafos, nós precisaríamos prover um método <code>draw</code> (desenhar), um método <code>contains</code> (contém) e o método <code>getConnectionPoint</code>, que descreve a forma da borda do nó. O código é dado abaixo, e a Figura 22.4 mostra o diagrama de classes destas classes (desenhados, é claro, com Violet).</p>

<code>
public class CircleNode extends AbstractNode
{
  public CircleNode(Color aColor)
  {
    size = DEFAULT_SIZE;
    x = 0;
    y = 0;
    color = aColor;
  }

  public void draw(Graphics2D g2)
  {
    Ellipse2D circle = new Ellipse2D.Double(x, y, size, size);
    Color oldColor = g2.getColor();
    g2.setColor(color);
    g2.fill(circle);
    g2.setColor(oldColor);
    g2.draw(circle);
  }

  public boolean contains(Point2D p)
  {
    Ellipse2D circle = new Ellipse2D.Double(x, y, size, size);
    return circle.contains(p);
  }

  public Point2D getConnectionPoint(Point2D other)
  {
    double centerX = x + size / 2;
    double centerY = y + size / 2;
    double dx = other.getX() - centerX;
    double dy = other.getY() - centerY;
    double distance = Math.sqrt(dx * dx + dy * dy);
    if (distance == 0) return other;
    else return new Point2D.Double(
      centerX + dx * (size / 2) / distance,
      centerY + dy * (size / 2) / distance);
  }

  private double x, y, size, color;
  private static final int DEFAULT_SIZE = 20;
}

public class LineEdge extends AbstractEdge
{
  public void draw(Graphics2D g2)
  { g2.draw(getConnectionPoints()); }

  public boolean contains(Point2D aPoint)
  {
    final double MAX_DIST = 2;
    return getConnectionPoints().ptSegDist(aPoint) < MAX_DIST;
  }
}
</code>

<p>Figura 22.4: Diagrama de Classes para um Grafo Simples</p>

<p>Em resumo, Violet provê um framework simples para edição de grafos. Para obter uma instância do editor, definir classes nó e aresta e oferecer métodos em uma classe de grafos que gere objetos protótipo nó e aresta.</p>

<p>É claro, há outros frameworks de grafos disponíveis, como JGraph [Ald02] e JUNG(2). Contudo, estes frameworks são consideravelmente mais complexos e eles fornecem frameworks para desenho de grafos, não para aplicações que desenham grafos.</p>


<h2>O Uso de Propriedades JavaBeans</h2>

<p>Nos dias áureos do uso do Java no lado cliente, a especificação JavaBeans foi desenvolvida com o objetivo de proporcionar mecanismos portáveis de edição de componentes de interface gráfica em ambientes visuais de construção de interfaces gráficas. A visão era de que um componente criado por terceiros pudesse ser inserido em qualquer construtor de interfaces gráficas, onde suas propriedades poderiam ser configuradas do mesmo modo que componentes padrão como botões, caixas de texto e outros.</p>

<p>Java não possui suporte nativo a propriedades. Ao invés disto, propriedades JavaBeans podem ser acessadas por pares de métodos de acesso (<i>getters</i>) e alteração (<i>setters</i>) de atributos, ou especificados em classes <code>BeanInfo</code> associadas. Além disto, editores de propriedades podem ser especificados para editar visualmente valores de propriedades. O JDK contém até mesmo alguns editores básicos de propriedades, por exemplo, para a classe <code>java.awt.Color</code>.</p>

<p>O framework de Violet faz pleno uso da especificação JavaBeans. Por exemplo, a classe <code>CircleNode</code> pode expor uma propriedade cor simplesmente provendo dois métodos:</p>

<code>
public void setColor(Color newValue)
public Color getColor()
</code>

<p>Nenhum trabalho adicional é necessário. O editor de grafos pode agora alterar cores de nós circulares (Figura 22.5).</p>


<p>Figura 22.5: Editando Cores de Círculos com o Editor JavaBeans de Cores padrão</p>


</body>
</html>

